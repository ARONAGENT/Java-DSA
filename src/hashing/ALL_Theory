Detailed Theory: Frequency Finding Approaches

1. Find Element Frequency – Normal Approach
Concept:
Iterate over the array for each element and count occurrences by comparing with all other elements.
Uses nested loops → Time complexity O(N²).

Pros:
No extra memory needed (only a counter).
Very simple to understand.

Cons:
Very slow for large datasets (e.g., 10⁵ elements will be too slow).
Not practical in competitive programming or production.

2. Understand Max Array Length & Prefer HashMap
Concept:
In Java, arrays have a maximum length limited by JVM heap size (-Xmx), not just by the int index limit.
Large arrays can cause OutOfMemoryError.
HashMap provides a memory-flexible way to store frequencies without reserving a huge continuous memory block.

Key Points:
Arrays are faster for small, bounded ranges (e.g., lowercase letters).
HashMaps are better for large, sparse ranges (e.g., arbitrary integers or strings).
Avoid large static arrays when element values are unpredictable.

3. Optimal Hashing with Integers
Concept:
If integers are within a known small range (e.g., 0–10⁶), use a fixed-size array to store counts.
Precompute: hash[arr[i]]++.

Pros:
O(N) time complexity.
O(max_element) space complexity.
Direct index access → fastest lookup.

Cons:
Memory waste if the range is large but the dataset is sparse.
Not feasible if element values are huge (e.g., 10⁹).

4. Optimal Hashing with Lowercase Characters
Concept:
Since 'a' to 'z' is a fixed range (26), use an array of size 26.
Index: hash[ch - 'a'].

Pros:
Extremely fast (O(1) lookup).
Tiny memory footprint.
Perfect for problems limited to lowercase letters.

Cons:
Only works for lowercase English letters.

5. Optimal Hashing with Uppercase Characters

Concept:
Same as lowercase, but 'A' to 'Z' → Array size 26.
Index: hash[ch - 'A'].

Pros & Cons:
Same as lowercase approach, but works for uppercase only.

6. Optimal Hashing with All 255 Characters

Concept:
Works for all ASCII characters by making an array of size 256.

Index: hash[ch].

Pros:
Handles any ASCII character (letters, numbers, symbols).
O(1) lookup.

Cons:

Uses slightly more memory than needed if dataset is small.
Still not ideal for Unicode beyond ASCII range.

7. Most Optimal HashMap with Integers & Characters
Concept:
Use HashMap<K, Integer> where K can be Integer or Character.
No fixed size, memory grows dynamically as needed.

Pros:

Works for any data type, any range.
No wasted space for unused elements.
Good for sparse datasets.

Cons:
Slightly slower than arrays due to hashing overhead.
Requires extra object storage (more memory per element).

8. Theory Summary – Choosing the Right Approach
| Data Type / Range | Best Approach       | Time | Space              | Notes               |
| ----------------- | ------------------- | ---- | ------------------ | ------------------- |
| Small fixed range | Array-based hashing | O(N) | O(range)           | Fastest             |
| Lowercase letters | Array of size 26    | O(N) | O(26)              | Best for `'a'-'z'`  |
| Uppercase letters | Array of size 26    | O(N) | O(26)              | Best for `'A'-'Z'`  |
| All ASCII chars   | Array of size 256   | O(N) | O(256)             | Covers most symbols |
| Large/sparse data | HashMap             | O(N) | O(unique elements) | Flexible            |
| Unknown range     | HashMap             | O(N) | O(unique elements) | Safe choice         |


Final Takeaway:

Use array-based hashing for small, predictable ranges.
Use HashMap when the range is unknown or huge.
Always consider memory constraints before choosing.

