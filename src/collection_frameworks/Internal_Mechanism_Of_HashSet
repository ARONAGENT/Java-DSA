## ğŸ” **HashSet Duplicate Kyun Store Nahi Karta â€“ Internal Working Explained**

---

### âœ… 1. **HashSet Internally HashMap ka Use karta hai**
- Jab tum likhte ho:
  set.add("Tokyo");

  Toh ye element `"Tokyo"` actually `HashMap` ke key ki tarah store hota hai.
- `HashSet` ke andar ek **dummy value** bhi store hoti hai, usually koi constant jaise `"PRESENT"`.

  Internally:
  map.put("Tokyo", PRESENT);


---

### âœ… 2. **Hashing aur Buckets**
- Har element ka ek `hashCode()` banta hai, jo ek integer hota hai.
- Ye hashCode decide karta hai ki element ko kis bucket (index) mein store kiya jaayega.

  ğŸ§  Socho buckets ek array ke boxes hain â€” har element ek particular box mein jaata hai.

  Example:
  `"Tokyo".hashCode()` â†’ 233421
  Phir usko kisi bucket mein map kiya jaata hai: `bucket = hashCode % capacity`

---

### âœ… 3. **Collision Hona**
- Kabhi kabhi do alag values ka `hashCode()` same bucket ko point kar deta hai.
  Is situation ko **collision** kehte hain.

- Java is collision ko handle karta hai:
  - **Java 7** mein: Linked List use hoti thi.
  - **Java 8+** mein: Agar ek bucket mein zyada elements ho jaayein toh **Red-Black Tree** use hota hai.

  ğŸ”´âš« Red-Black Tree ek self-balancing Binary Search Tree (BST) hoti hai.
  âœ”ï¸ Ye har insertion ke baad khud ko balance karti hai taaki searching, insertion, deletion operations O(log n) time mein ho sake.
  âœ”ï¸ Java 8+ mein jab ek bucket mein 8 se zyada elements ho jaate hain, toh LinkedList ki jagah Red-Black Tree use hota hai â€” taaki performance degrade na ho.

---

### âœ… 4. **Duplicate Value Add Nahi Hoti Kyun?**
- Jab tum koi naya element add karte ho:
  1. Pehle uska `hashCode()` nikala jaata hai.
  2. Fir check hota hai ki us bucket mein koi element pehle se toh nahi hai.
     - Agar hai, toh `equals()` method use karke compare kiya jaata hai.
- Agar `equals()` return kare `true` â†’ **Duplicate hai** â†’ Add nahi hoga.
- Agar `false` â†’ Naya value hai â†’ Add ho jaayega.

---

### âœ… 5. **Time Complexity**
- HashSet mein operations jaise:
  - `add()`
  - `contains()`
  - `remove()`

  Yeh sab average case mein O(1) time lete hain â€” matlab super fast!

  âš ï¸ Kabhi kabhi (collision ke time) ye O(n) bhi ho sakta hai, but rarely.

---

### ğŸ§  Example:

```java
Set<String> set = new HashSet<>();
set.add("Tokyo");  // hashCode â†’ bucket 3
set.add("Osaka");  // hashCode â†’ bucket 7
set.add("Tokyo");  // same bucket 3, equals() true â†’ duplicate â†’ not added
```

---

### ğŸ“Œ Important Points Summary Table
--------------------------------------------------------------------
| Feature              | Description                               |
|----------------------|-------------------------------------------|
| âŒ Duplicate Allowed? | Nahi                                     |
| âœ… Fast Operations    | Haan (O(1))                              |
| âŒ Insertion Order?   | Maintain nahi hoti                       |
| âœ… null Allowed?      | Sirf ek `null`                           |
| âŒ Thread-Safe?       | Nahi (synchronize manually karna padega) |
 ------------------------------------------------------------------
---